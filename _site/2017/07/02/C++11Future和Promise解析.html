<!DOCTYPE html>
<html>
<head>
　　<meta http-equiv="content-type" content="text/html; charset=utf-8" />
　　<title>C++11future和promise解析</title>
</head>
<body>

　　<h1 id="c11-future和promise解析">C++11 Future和Promise解析</h1>

<p>Future是用来存储异步操作的结果的一个模板类</p>

<ul>
  <li>获得future的方式有以下几种：
    <div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="mi">1</span><span class="o">:</span><span class="n">future</span> <span class="n">from</span> <span class="n">packaged_task</span><span class="o">:</span>
  <span class="n">std</span><span class="o">::</span><span class="n">packaged_task</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">()</span><span class="o">&gt;</span> <span class="n">task</span><span class="p">([](){</span> <span class="k">return</span> <span class="mi">7</span><span class="p">;</span> <span class="p">});</span> <span class="c1">// wrap the function
</span>  <span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">f1</span> <span class="o">=</span> <span class="n">task</span><span class="p">.</span><span class="n">get_future</span><span class="p">();</span>  <span class="c1">// get a future
</span><span class="mi">2</span><span class="o">:</span><span class="n">future</span> <span class="n">from</span> <span class="n">a</span> <span class="n">async</span><span class="o">:</span>
  <span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">f2</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">async</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">launch</span><span class="o">::</span><span class="n">async</span><span class="p">,</span> <span class="p">[](){</span> <span class="k">return</span> <span class="mi">8</span><span class="p">;</span> <span class="p">});</span>
<span class="mi">3</span><span class="o">:</span><span class="n">future</span> <span class="n">from</span> <span class="n">a</span> <span class="n">promise</span>
  <span class="n">std</span><span class="o">::</span><span class="n">promise</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">p</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">f3</span> <span class="o">=</span> <span class="n">p</span><span class="p">.</span><span class="n">get_future</span><span class="p">();</span>
</code></pre>
    </div>
    <p>摘自<a href="http://en.cppreference.com/w/cpp/thread/future">cppreference.com</a></p>
  </li>
  <li>重要的成员函数：
    <ol>
      <li><strong>get</strong>：返回结果，当future的结果还未有效时，会等待future的结果变成有效。</li>
      <li><strong>wait</strong>：等待结果变成有效，这个函数可以用来等待同步。</li>
      <li><strong>wait_for</strong>:等待一段时间后返回一个future的当前的状态。
```c++
// future::wait_for
#include <iostream>       // std::cout
#include <future>         // std::async, std::future
#include <chrono>         // std::chrono::milliseconds</chrono></future></iostream></li>
    </ol>
  </li>
</ul>

<p>// a non-optimized way of checking for prime numbers:
bool is_prime (int x) {
  for (int i=2; i&lt;x; ++i) if (x%i==0) return false;
  return true;
}</p>

<p>int main ()
{
  // call function asynchronously:
  std::future<bool> fut = std::async (is_prime,700020007);</bool></p>

<p>// do something while waiting for function to set future:
  std::cout « “checking, please wait”;
  std::chrono::milliseconds span (100);
  while (fut.wait_for(span)==std::future_status::timeout)
    std::cout « ’.’;</p>

<p>bool x = fut.get();</p>

<p>std::cout « “\n700020007 “ « (x?”is”:”is not”) « ” prime.\n”;</p>

<p>return 0;
}</p>
<div class="highlighter-rouge"><pre class="highlight"><code>摘自[cplusplus.com](http://www.cplusplus.com/reference/future/future/wait_for/)

4. **wait_until**:在某个时间段内future还没有有效的话，返回timeout;这个函数会阻塞调用的进程。
* **future**和**promise**的配对：promise通过get_future函数和future进行绑定。promise通过set函数（四种set_value、set_value_at_thread_exit、set_exception、set_exception_at_thread_exit）进行设置值，然后使得future有效。
* **shared_future**能够拥有多个wait函数可用于多个子线程的之间的同步等待。
示例
```c++
#include &lt;iostream&gt;
#include &lt;future&gt;
#include &lt;chrono&gt;
 
int main()
{   
    std::promise&lt;void&gt; ready_promise, t1_ready_promise, t2_ready_promise;
    std::shared_future&lt;void&gt; ready_future(ready_promise.get_future());
 
    std::chrono::time_point&lt;std::chrono::high_resolution_clock&gt; start;
 
    auto fun1 = [&amp;, ready_future]() -&gt; std::chrono::duration&lt;double, std::milli&gt; 
    {
        t1_ready_promise.set_value();
        ready_future.wait(); // waits for the signal from main()
        return std::chrono::high_resolution_clock::now() - start;
    };
 
 
    auto fun2 = [&amp;, ready_future]() -&gt; std::chrono::duration&lt;double, std::milli&gt; 
    {
        t2_ready_promise.set_value();
        ready_future.wait(); // waits for the signal from main()
        return std::chrono::high_resolution_clock::now() - start;
    };
 
    auto result1 = std::async(std::launch::async, fun1);
    auto result2 = std::async(std::launch::async, fun2);
 
    // wait for the threads to become ready
    t1_ready_promise.get_future().wait();
    t2_ready_promise.get_future().wait();
 
    // the threads are ready, start the clock
    start = std::chrono::high_resolution_clock::now();
 
    // signal the threads to go
    ready_promise.set_value();
 
    std::cout &lt;&lt; "Thread 1 received the signal "
              &lt;&lt; result1.get().count() &lt;&lt; " ms after start\n"
              &lt;&lt; "Thread 2 received the signal "
              &lt;&lt; result2.get().count() &lt;&lt; " ms after start\n";
}
</code></pre>
</div>
<p>摘自<a href="http://en.cppreference.com/w/cpp/thread/shared_future">cppreference.com</a></p>


</body>
</html>